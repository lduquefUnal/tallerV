/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// Librerías estándar
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// Librerías de STM32 y drivers
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "exti_driver_hal.h"
#include "timer_driver_hal.h"
#include "SysTickDriver.h"
#include "magic.h"
#include "usart_driver_hal.h"
#include "pwm_driver_hal.h"

// Definiciones de macros
#define DEBOUNCE_DELAY_MS 250  // Tiempo de antirrebote en milisegundos

// Handlers
GPIO_Handler_t gpioRx = {0};     // Pin C6
GPIO_Handler_t gpioTx = {0};   // Pin C7
GPIO_Handler_t userLed = {0};
// Timers,ECTI Y PWM
Timer_Handler_t blinkyTimer = {0};    // TIM2
USART_Handler_t usart6Handler ;

#define BUFFER_SIZE 64
char rxBuffer[BUFFER_SIZE];  // Buffer de recepción
uint8_t rxIndex = 0;         // Índice para almacenar caracteres
uint8_t sendMsg = 0 ;


uint8_t prueba = 10 ;
typedef enum {
    WAITING_COMMAND,
    PROCESSING_COMMAND
} USART_State_t;

USART_State_t usartState = WAITING_COMMAND;
uint8_t commandReceived = 0;
// Prototipos de funciones auxiliares
void init_System(void);
void togglePin(void);
void init_usart(void);
void processUSARTCommand(void);
void char2str(char);
void menu(void);
/*
 * The main function, where everything happens.
 */
int main (void){

	init_System();
	configMagic();
	init_usart();

	while(1){
		processUSARTCommand();
		// Agregar mensaje de depuración para ver si el loop funciona
		if (commandReceived) {
			usart_writeMsg(&usart6Handler, "\n Comando recibido en el buffer \n");
		}
}}

//void togglePin(void){
	//	gpio_TogglePin(&userLed);  // Alternar el estado del LED
	//	delay_ms(400);
	//}


void init_usart(void){
	usart6Handler.ptrUSARTx = USART6;
	usart6Handler.USART_Config.mode =  USART_MODE_RXTX;
	usart6Handler.USART_Config.baudrate = USART_BAUDRATE_115200;
	usart6Handler.USART_Config.datasize = USART_DATASIZE_8BIT;
	usart6Handler.USART_Config.parity = USART_PARITY_NONE ;
	usart6Handler.USART_Config.stopbits = USART_STOPBIT_1;
	usart6Handler.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;
	usart6Handler.USART_Config.enableIntTX = USART_TX_INTERRUP_DISABLE;
	usart_Config(&usart6Handler);
}
void init_System(void){

	//Configuramos el pin
	userLed.pGPIOx							= GPIOH;
	userLed.pinConfig.GPIO_PinNumber		= PIN_1;
	userLed.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	= GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	//Cargamos la configuracion  en los registros que gobiernan el puerto.
	gpio_Config(&userLed);


	gpioTx.pGPIOx                           = GPIOC;
	gpioTx.pinConfig.GPIO_PinNumber         = PIN_6 ;
	gpioTx.pinConfig.GPIO_PinMode           = GPIO_MODE_ALTFN;
	gpioTx.pinConfig.GPIO_PinOutputType     = GPIO_OTYPE_PUSHPULL;
	gpioTx.pinConfig.GPIO_PinOutputSpeed    = GPIO_OSPEED_FAST;
	gpioTx.pinConfig.GPIO_PinPuPdControl    = GPIO_PUPDR_PULLUP;
	gpioTx.pinConfig.GPIO_PinAltFunMode     = AF8;

	// cargamos
	gpio_Config(&gpioTx);

	gpioRx.pGPIOx                           = GPIOC;
	gpioRx.pinConfig.GPIO_PinNumber         = PIN_7 ;
	gpioRx.pinConfig.GPIO_PinMode           = GPIO_MODE_ALTFN;
	gpioRx.pinConfig.GPIO_PinOutputType     = GPIO_OTYPE_PUSHPULL;
	gpioRx.pinConfig.GPIO_PinOutputSpeed    = GPIO_OSPEED_FAST;
	gpioRx.pinConfig.GPIO_PinPuPdControl    = GPIO_PUPDR_PULLUP;
	gpioRx.pinConfig.GPIO_PinAltFunMode     = AF8;

	gpio_Config(&gpioRx);

	blinkyTimer.pTIMx								= TIM2;
	blinkyTimer.TIMx_Config.TIMx_mode				= TIMER_UP_COUNTER;
	blinkyTimer.TIMx_Config.TIMx_Prescaler  		= 16000; //1ms conversion
	blinkyTimer.TIMx_Config.TIMx_Period				= 500;
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable 	= TIMER_INT_ENABLE;

	timer_Config(&blinkyTimer);
	timer_SetState(&blinkyTimer, TIMER_ON);


}


void processUSARTCommand(void) {

    switch (usartState) {
	case WAITING_COMMAND:
		if (commandReceived) {
			usartState = PROCESSING_COMMAND; // Cambiar de estado
		}
		break;

	case PROCESSING_COMMAND:
//		sprintf(rxBuffer, "la prueba es : %u \n", prueba);
//		usart_writeMsg(&usart6Handler, rxBuffer);
		if (strcmp(rxBuffer,"help") == 0) {
			menu();

		} else {
			usart_writeMsg(&usart6Handler, "Comando no reconocido.\n");
		}

		commandReceived = 0; // Reset flag
		usartState = WAITING_COMMAND; // Volver a esperar comandos
		break;
    }
}

/*
 * Overwrite function
 */
void Timer2_Callback(void){
	gpio_TogglePin(&userLed);
}

void usart6_RxCallback(void){

    char receivedChar = (char) usart_getRxData(&usart6Handler);
    char2str(receivedChar);
}


void char2str(char receivedChar) {
	if (rxIndex < BUFFER_SIZE - 1) { // Evitar desbordamiento
		if (receivedChar == '@') { // Si se recibe '@', se procesa el comando
			rxBuffer[rxIndex] = '\0'; // Finaliza la cadena correctamente
			rxIndex = 0; // Reiniciar índice para el próximo comando
			commandReceived = 1; // Indicar que hay un comando listo
		} else if (receivedChar != '\0') {
			rxBuffer[rxIndex] = receivedChar; // Agregar al buffer
			rxIndex++;
		}
	}
}
void menu(void){
	sprintf(rxBuffer,"Help Menu CMDs \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
	sprintf(rxBuffer,"1) help \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
	sprintf(rxBuffer,"2) dummy #A #B \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
	sprintf(rxBuffer,"3) usermsg \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
	sprintf(rxBuffer,"4) usermsg \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
	sprintf(rxBuffer,"5) usermsg \n");
	usart_writeMsg(&usart6Handler,rxBuffer);
}
/*
 * Esta función sirve para detectar problemas de parametros
 * incorrectos al momento de ejecutar un programa.
 */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		//Problems
	}
}
